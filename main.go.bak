package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/joho/godotenv"
	"github.com/sirupsen/logrus"

	"github.com/shahidshabbir-se/renhance-email-detector/internal/db"
	"github.com/shahidshabbir-se/renhance-email-detector/internal/db/sqlc"
	"github.com/shahidshabbir-se/renhance-email-detector/internal/logger"
)

var (
	ctx         = context.Background()
	log         = logrus.New()
	redisClient *redis.Client
	pgPool      = db.InitPostgres(ctx, log) // properly initialized
	dbQueries   *sqlc.Queries
)

type Job struct {
	JobID       string `json:"job_id"`
	CompanyName string `json:"company_name"`
}

type HunterResponse struct {
	Data struct {
		Emails []struct {
			Value string `json:"value"`
		} `json:"emails"`
	} `json:"data"`
}

func init() {
	_ = godotenv.Load()
	logger.InitLogger(log)

	redisClient = db.InitRedis(ctx, log)
	dbQueries = sqlc.New(pgPool)
}

func main() {
	defer pgPool.Close()

	go runWorker()
	go runClient()

	select {} // block forever
}

func runWorker() {
	log.Info("Worker started")
	for {
		jobJSON, err := redisClient.BLPop(ctx, 0*time.Second, "email_detection_jobs").Result()
		if err != nil || len(jobJSON) < 2 {
			continue
		}

		var job Job
		if err := json.Unmarshal([]byte(jobJSON[1]), &job); err != nil {
			log.WithError(err).Error("Invalid job JSON")
			continue
		}

		log.WithField("job_id", job.JobID).Info("Processing job")

		emails, err := detectEmails(job.CompanyName)
		if err != nil {
			log.WithError(err).Error("Email detection failed")
			continue
		}

		first := ""
		if len(emails) > 0 {
			first = emails[0]
		}

		if err := saveResult(job.JobID, job.CompanyName, first); err != nil {
			log.WithError(err).Error("Failed to save result")
		}

		resultKey := fmt.Sprintf("result:%s", job.JobID)
		if resultJSON, _ := json.Marshal(emails); len(emails) > 0 {
			if err := redisClient.Set(ctx, resultKey, resultJSON, 24*time.Hour).Err(); err != nil {
				log.WithError(err).Error("Redis set failed")
			}
		}

		log.WithFields(logrus.Fields{
			"job_id": job.JobID,
			"emails": len(emails),
		}).Info("Job completed")
	}
}

func runClient() {
	log.Info("Client started")

	jobs := []Job{
		{JobID: "job-1", CompanyName: "example"},
		{JobID: "job-2", CompanyName: "openai"},
	}

	for _, job := range jobs {
		if err := enqueueJob(job); err != nil {
			log.WithError(err).WithField("job_id", job.JobID).Error("Failed to enqueue job")
		} else {
			log.WithFields(logrus.Fields{
				"job_id":  job.JobID,
				"company": job.CompanyName,
			}).Info("Enqueued job")
		}
	}
}

func enqueueJob(job Job) error {
	jobJSON, err := json.Marshal(job)
	if err != nil {
		return err
	}
	return redisClient.RPush(ctx, "email_detection_jobs", jobJSON).Err()
}

func detectEmails(domain string) ([]string, error) {
	req, _ := http.NewRequest("GET", "https://api.hunter.io/v2/domain-search", nil)
	q := req.URL.Query()
	q.Add("domain", domain)
	q.Add("api_key", os.Getenv("HUNTER_API_KEY"))
	req.URL.RawQuery = q.Encode()

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result HunterResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	emails := make([]string, 0, len(result.Data.Emails))
	for _, e := range result.Data.Emails {
		emails = append(emails, e.Value)
	}

	return emails, nil
}

func saveResult(jobID, company, email string) error {
	emailText := pgtype.Text{String: email, Valid: email != ""}
	return dbQueries.InsertResult(ctx, sqlc.InsertResultParams{
		JobID:   jobID,
		Company: company,
		Email:   emailText,
	})
}
